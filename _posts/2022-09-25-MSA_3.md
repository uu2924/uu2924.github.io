---
title: "마이크로 서비스 어플리케이션 아키텍처"
excerpt: "도메인 주도 설계로 시작하는 마이크로서비스 개발"

categories:
   - MSA
tags:
   -MSA
   -DDD
   -Cloud
last_modified_at: 2022-09-27
published: true
toc: true
toc_sticky: true
toc_label: 목차
---

> 출처: [도메인 주도 설계로 시작하는 마이크로서비스 개발]

### 관심사의 분리 ###
#### 비즈니스 로직 ####
소프트웨어의 핵심은 비즈니스로직이라는 말이있다.
비즈니스 로직은 시스템의 목적인 비즈니스 영역의 업무 규칙(rule), 흐름(flow), 개념(concept)을 표현하는 용어이다.
소프트웨어를 개발할 때 비즈니스 표현하는 비즈니스 영역과 기술 문제를 처리하는 기술영역은 철저히 분리해야한다.

#### 데이터베이스 중심 아키텍처의 문제점 ####
데이터베이스 중심 아키텍처란 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한 뒤
이를 적용한 물리 테이블 모델을 중심으로 어플리케이션을 구현하는 방식이다.
스프링 프레임워크를 활용한다면 컨트롤러(Controller), 서비스(Service), DB I/O(Database Input/Output), DTO(Data Transfer Object)로 구성되고,
데이터 처리는 SQL 매핑 프레임워크인 마이바티스(MyBatis)를 사용한다. 여기서 비즈니스 개념과 규칙들은 SQL 질의에 존재한다.
이런 구조에서는 업무가 복잡해지면 관리가 힘들어지고 성능도 떨어지게된다.

### 헥사고날 아키텍처와 클린 아키텍처 ###

#### 레이어드 아키텍처 ####
레이어는 물리적인 티어 내부의 논리적인 분할을 의미한다.
아래 그림은 마틴 파울러가 <<엔터프라이즈 어플리케이션 아키텍처 패턴>>에서 구분한 레이어드 아키텍처 유형이다.
프렌젠테이션, 비즈니스로직, 데이터액세스 3계층으로 구분한다.

[그림] 전통적인 3계층 아키텍처  
![ch3_1](https://user-images.githubusercontent.com/50389148/192435475-087934ce-b410-41e3-b912-bf852616699e.PNG)

__레이어드 아키텍처는 레이어 간 응집성을 높이고 의존도를 낮추기 위한 규칙들__  
1. 상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.  
2. 상위 계층은 하위의 여러 계층을 모두 알 필요 없이 바로 밑의 근접 계층만 활용한다.  
3. 상위 계층이 하위 계층에 영향을 받지 않게 구성해야한다.  
4. 하위 계층은 자신을 사용하는 상위 계층을 알지 못하게 구성해야 한다.
5. 계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.(구현 클래스에 직접 의존하지 않는 약한 결합성)

[그림] 인터페이스 호출을 통한 다형성 추구  
![ch3_2](https://user-images.githubusercontent.com/50389148/192435461-2392d1b9-03a2-46d3-bf8f-dd47b870661a.PNG)

위 그림에서 보면 데이터 액세스 계층의 구현체인 클래스 C가 클래스 D로 교체될 경우
비즈니스 로직 계층(클래스 A)은 영향을 받지 않지만,
데이터 액세스 인터페이스 B가 변경되면 인터페이스 B에 의존하는 비즈니스 로직 계층의 클래스 A는 영향을 받게된다.
이렇게 데이터 액세스 인터페이스가 데이터 액세스 계층에 존재하면 상위 계층이 하위 계층에 의존하게 된다.
때문에 DIP(의존성 역전 원칙)을 적용해 데이터 액세스 계층에서 정의한 인터페이스를 비즈니스 로직 계층으로 옮긴다.
비즈니스 로직을 보통 고수준 영역이라 하고, 프레젠테이션 및 데이터 액세스 계층을 저수준 영역이라고 하는데,
데이터 액세스 계층을 구현 할 때 고수준의 비즈니스 로직 계층에서 정의함으로써
기존의 하향식 의존 관계를 역전시켜 고수준 영역이 저수준 영역의 변경에 영향을 받지 않도록 하는 것이다.
 
#### 헥사고날 아키텍처 ####  
헥사고날 아키텍서는 앨리스테어 콕번(Alistair Cockburn)이 제시한 아키텍처로 '포트 앤드 어댑터 아키텍처(Ports and adapters architecture)'라고도 한다.
헥사고날 아키텍처에서 고수준의 비즈니스 로직은 내부영역으로 표현하고 저수준의 인터페이스를 처리하는 로직은 외부영역으로 표현한다.
내부영역은 순수한 비즈니스 로직을 표현하는 기술 독립적인 영역이다. 그리고 외부 영역과 연계되는 포트를 가지고 있다.
외부 영역은 외부에서 들어오는 요청을 처리하는 인바운드 어댑터와 비즈니스 로직에 의해 호출되어 외부로 나가는 아웃바운드 어댑터로 구성된다.

[그림] 헥사고날 아키텍처의 포트와 어댑터  
![ch3_3](https://user-images.githubusercontent.com/50389148/192435464-0529403a-f575-43fe-90e4-d61b1c43d2c2.PNG)

헥사고날 아키턱처는 내부 영역에 구성된 포트를 이용해 외부영역에 전혀 의존하지 않고 동작한다. 
포트는 인바운드/아웃바운드 포트로 구분되는데, 인바운드 포트는 내부 영역 사용을 위한 것이며, 외부 영역 인바운드 어댑터가 호출한다.
아웃바운드 포트는 내부 영역이 외부를 호출하는 방법을 정의한다.
외부 영역에 존재하는 인바운드 어댑터는 REST API에서 발행하는 컨트롤러, 스프링 MVC 컨트롤러, 커맨드 핸들러, 이벤트 메시지 구독 핸들러 등이 있고,
아웃바운드 어댑터로는 데이터 액세스 처리를 담당하는 DAO, 이벤트 메시지를 발행하는 클래스, 외부 서비스를 호출하는 프록시 등이 있다.

#### 클린 아키텍처 ####  
클린 아키텍처는 로버트 C. 마틴이 고안한 아키텍처로 소프트웨어를 부드럽게 만드는 구조 가치를 중요하게 생각한다.
클린 아키텍처는 아래 그림 처럼 여러 겹으로 둘러싸인 영역으로 표현된다.

[그림] 클린 아키텍처  
![ch3_3_2](https://user-images.githubusercontent.com/50389148/192443261-63b0c5fb-7b67-494a-9f5b-2f9467e93d9b.PNG)

정중앙에는 엔티티는 핵심 업무 규칙과 데이터가 결합된 객체를 말한다.
예를 들어 도서대출 시스템의 대출/반납, 은행의 입출금과 같은 업무 절차가 업무 규칙이 되고 이를 수행하기 위해 필요한 데이터가 결합된다.
그 다음으로 엔티티를 감싸는 것은 유즈케이스(UseCase) 객체이다.
유즈케이스는  어플리케이션에 특화된 업무 규칙을 표현하며, 엔티티 내부의 핵식 업무 규칙을 호출하여 시스템을 사용하는 흐름을 담는다.
엔티티는 프레임워크나 데이터베이스 등에 의존하지 않고 유즈케이스 객체를 통해서만 조작된다.
마지막으로 유즈케이스를 감싸는 모든 영역은 세부사항이다.
세부사항에는 입출력 장치, 저장소, 웹 시스템, 프레임워크 등이 될 수 있으며,
세부사항과 유즈케이스는 의존 관계 역전의 원칙을 사용하여 플러그인처럼 유연하게 교체/확장될 수 있도록 한다.

### 마이크로서비스 구조 정의 ###
마이크로서비스 아키텍처에서 각 서비스는 각기 목표와 용도에 따라 명확하게 분리돼야 하고,
각 서비스의 목적에 따라 적절한 개발 언어 및 저장소, 내부 아키텍처를 정의하는 것이 바람직한다.

[그림] 폴리그랏 마이크로 서비스  
![ch3_4](https://user-images.githubusercontent.com/50389148/192435465-eca329c6-a316-44a5-a40c-c0f4d18a45aa.png)

__마이크로 서비스 아키텍처가 지향하는 원칙__  
1. 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮춘다.
2. 업무규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.
3. 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분한다.
4. 고수준 영역은 저수준 영역에 의존하지 않고, 저수준 영역이 고수준 영역에 의존해야 한다.
5. 저수준 영역은 언제든지 교체, 확장 가능해야하며, 이 같은 변화가 고수준 영역에 영향을 주어서는 안된다.
6. 자바처럼 인터페이스 및 추상 클래스를 지원하는 언어는 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전 원칙을 적용한다.
7. 인테페이스는 고수준의 안정된 영역에 존재하며, 저수준의 어댑터가 이를 구현한다.

[그림] 마이크로서비스의 내부 구조 예시  
![ch3_5](https://user-images.githubusercontent.com/50389148/192435470-f61fe81e-cf9f-44ae-aad9-c0c2ee1ce175.PNG)

도메인은 핵심 비즈니스 개념과 규칙을 구현하며, 서비스는 도메인을 호출해 업무를 처리하는 절차를 기술한다.
내부영역의 서비스 인터페이스는 외부영역에서 내부영역을 사용할 수 있도록 API를 제공하고 구현한다.
리포지토리 인터페이스는 비즈니스를 처리하는데 필요한 기본적인 저장소 처리 사항을 추상화해 정의한다.
외부영역에는 저장소 처리 어댑터뿐만아니라 다양한 인바운드, 아웃바운드를 처리하는 어댑터(REST API 처리 어댑터, 이벤트 메시지 처리 어댑터 등)가 있다.

#### 내부 영역- 업무 규칙 ####
업무 규칙을 정의하는 내부 영역에는 서비스 인터페이스, 서비스 구현체, 도메인, 리포지토리 인터페이스,
도메인 이벤트 인터페이스, API 프락시 인터페이스가 존재한다.
서비스 인터페이스는 외부 영역이 내부 영역에 대해 너무 많이 알지 못하게 하는 역할을 한다.
리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프록시 인터페이스는 의존 관계 역전의 원칙을 지원한다.
서비스와 도메인은 클린 아키텍처의 유즈케이스와 엔티티의 역할과 같다.
도메인은 비즈니스 개념을 표현하고 서비스는 도메인을 활용해 시스템 흐름 처리를 수행한다.

__트랜잭션 스크립트 패턴__  
트랜잭션 스크립트 패턴에서는 도메인 객체가 행위를 가지고 있지 않고 비즈니스 행위의 책임은 서비스에 있다.
이런방식은 시간이 지남에 따라 서비스가 비대해지고 도메인 객체는 정보의 묶음 역할만 수행하게 된다.

__도메인 모델 패턴__  
도메인 모델(Domain Model) 패턴은 도메인 객체가 데이터와 비스니스 행위를 모두 가지는 것이며,
도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉된다.
도메인 객체는 비즈니스 개념 및 행위를 수행하고, 서비스는 유즈케이스를 구현하기 위해 서비스 행위를 도메인 객체에 일부 위임해 처리한다.
서비스 책임이 도메인으로 적절히 분산되기 때문에 서비스가 비대해지지 않고 서비스 메서드는 단순해 진다.

[그림] 도메인 모델 패턴  
![ch3_6](https://user-images.githubusercontent.com/50389148/192435472-e13a59c3-2a61-4dc8-b526-53ed07e90c63.PNG)

__도메인 주도 설계의 애그리거트 패턴__  
도메인 모델링을 하다 보면 객체 간의 관계를 참조로 표현하게 되는데,
참조로 정의할 경우 일대다(one-to-many) 관계의 객체를 쉽게 사용할 수 있다는 장점이 있다.
그러나 업무가 복잡해지면 참조로인한 다단계 계층 구조가 생가고 점점 무거워 질 수 있다.
이를 개선할 방안으로 최상위에 존재하는 엔티티를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴이다.
1개 이상의 엔티티와 값 객체(Value Object)등이 묶인 개념적인 모음을 애그리거트라고 한다.

[그림]애그리거트 패턴  
![ch3_7](https://user-images.githubusercontent.com/50389148/192435473-6df97a47-642b-46f4-bb25-8c60d5eebdbc.PNG)

애그리거트 패턴에서 이처럼 애그리거트를 한 단위로 일관되게 처리하기 위해 다음과 같은 규칙을 부여한다.  
1. 애그리거트 루트만 참조한다.
2. 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조한다.
3. 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본키를 사용한다.
4. 기본키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 애그리거트를 함께 수정하는 실수를 방지한다.
5. 하나의 트랜잭션으로 하나의 애그리커트만 생성 및 수정한다.

#### 외부 영역 - 세부사항 ####
외부 영역은 내부 영역의 서비스를 사용하는 인바운드 어댑터와 내부 영역에서 선언한 아웃바운드 인터페이스 등의 다양한 어댑터로 구성된다.

__API 퍼블리싱 어댑터__  
API 퍼블리싱 어댑터는 REST API를 발행하는 인바운드 어댑터이다.
내부 영역의 서비스 인터페이스를 호출해 REST 형식의 API로 제공한다.
명시적인 REST 리소스 명칭을 정의하고, 각 REST 메소드가 의도에 맞게 서비스 인터페이스를 호출한다.

__API 프락시 어댑터__  
API 프락시 어댑터는 다른 서비스의 API를 호출하는 아웃바운드 어댑터이다.

__저장소 처리 어댑터__  
저장소 처리 어댑터를 구현할 때는 OR 매핑 방식 또는 SQL 매핑 방식 중 데이터 처리 메커니즘을 선택해야한다.
일반적으로 트랜잭션 스크립트 패턴을 사용할 경우 SQL 매핑 방식을 사용하고,
도메인 모델 패턴을 사용할 경우 OR 매핑 방식을 많이 사용한다.

__도메인 이벤트 발행 어댑터__  
외부 아키텍처에서 서비스 간 비동기 메시지 통신에서 전달 대상이 되는 정보가 도메인 이벤트이다.
도메인 이벤트는 어떤 사건에 따른 상태의 변경 사항을 말하는데, '주문됨', '주문취소됨' 등의 명칭을 갖는 클래스로 구현되며,
사용자에게 전달되기 위해 도메인 이벤트 발행 어댑터를 통해 발행된다.
애그리거트 패턴을 사용할 경우 도메인 이벤트는 애그리거트에서 발생한 사건이 된다.
실제로 도메인 이벤트가 생성되는 위치는 내부영역이며,
도메인 이벤트 발행 어댑터는 내뷰 영역의 이벤트 인터페이스를 구현해 아웃바운드로 특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행한다.

__도메인 이벤트 핸들러__  
도메인 이벤트를 수신하는 인바운드 어댑터가 도메인 이벤트 핸들러이다.
외부에서 발행된 도메인 이벤트를 구독해 내부 영역으로 전달한다.


