---
title: "MSA의 이해"
excerpt: "도메인 주도 설계로 시작하는 마이크로서비스 개발"

categories:
   - MSA
tags:
   -MSA
   -DDD
   -Cloud
last_modified_at: 2022-09-25
published: true
toc: true
toc_sticky: true
toc_label: 목차
---

> 출처: [도메인 주도 설계로 시작하는 마이크로서비스 개발]


### 리얼액티브 ###

클라우드 인프라 기반의 마이크로서비스 아키텍처에서 가장 신경써야 할 요소는 무엇일까?
2014년 오나스 보네르(Jonas Boner) 등이 선언한 리액티브 선언문에서는 응답성(Responsive), 탄력성(Resilient), 유연성(Elastic), 메시지기반(Message Driven) 4가지 특성을 강조한다.  

1. 응답성(Responsive): 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공하는 것을 의미  
2. 탄력성(Resilient): 장애가 발생하거나 부분적으로 고장나도 시스템 전체가 고장 나지 않도록 빠르게 복구하는 능력  
3. 유연성(Elastic): 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공하는 것을 의미하며, 시스템 사용량에 비례해서 자원을 늘리거나 줄이는 능력  
4. 메시지 기반(Message Driven): 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향하는 것  

리액티브 시스템은 상황에 따라 빠르고 적절하게 방응하는 시스템을 의미한다.
신뢰성있는 응답과 빠른 장애 복구, 수요 증가에 따른 탄력적 대응을 위해 시스템 자체가 변화와 확장에 언제든지 대응 할 수 있는 유연성을 갖추어야한다.

### MSA 구성요소 및 MSA 패턴 ###

#### 마이크로서비스를 위한 인프라 구성요소 ####

__퍼블릭 클라우드와 베어 메탈, 프라이빗 클라우드 환경__  
AWS, 구글, 마이크로소프트, IBM 등 세계적인 플랫폼 사업자들이 자동화된 IaaS, PaaS 서비스를 통해 쉽고 편리한 인프라 구축 시스템 자원을 제공한다.
마이크로서비스는 어떠한 장비에도 구동 될 수 있고, 어떠한 환경에서도 유연하도록 구성되야 하므로 인프라를 고집하지 않는다.
그러나 MSA를 위한 베어 메탈을 고려한다면 별도의 프라이빗 클라우드 환경을 구축하는 것이 좋다.

__VM 과 컨테이너__  
가상 인프라 환경을 활용한다면 가상머신 제품과 컨테이너 기반 제품 중 하나를 선택해야한다.
가상 머신은 하이퍼바이저라를 이용해 하나의 시스템에서 여러 운영체제를 사용하는 기술이고,
컨테이너는 하이퍼바이저 없이 컨테이너 엔진을 이용해 사용 공간을 격리한다.
마이크로 서비스같은 작은 서비스를 패키지하고 배포하기에는 컨테이너 환경이 적합하다.

__컨테이너 오케스트레이션__  
컨테이너 기술을 사용한다면, 컨테이너가 많이짐에 따라 자동배치 및 복제, 장애복구, 확장 및 축소, 컨테이너 간 통신, 로드 밸런싱 등의 컨테이너 관리 기능이 필요해진다.
이것을 오케스트레이션이라 한다. CNCF 재단에서 제공해서 공개한 쿠버네티스는 손쉽게 컨테이너 플랫폼 환경을 구축할 수 있다.

#### 마이크로서비스 운영과 관리를 위한 플랫폼 패턴 ####

__개발 지원 환경: 데브옵스 인프라 구성__  
마이크로서비스를 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경을 데브옵스(DevOps)라 한다.
데브옵스는 개발과 운영을 병행 할 수 있게 지원하는 빌드, 테스트, 배포를 위한 자동환 환경을 말한다.
자동환된 빌드나 배포 작업을 보통 CI/CD라고 하며, 여기서는 CI(Continuous Intergration) 지속적 통합을 의미하고,
CD는 지속적 제공(Continuous Delivery) 및 지속적 배포(Continuous Deployment)를 의미한다.

1. 개발자들이 퇴근할 때 작성한 코드와 테스트 코드를 형상관리 시스템으로 보낸다.
2. 빌드 도구에서 매일 밤 형상관리 서버의 코드를 가져와 자동으로 빌드하고 테스트 코드를 실행한다.
3. 테스트 수행결과가 리포트 되고, 빌드된 소스는 스테이징 환경에 배포된다.
4. 다음날 테스터가 스테이징 환경에서 테스트를 수행하고 개발자가 그 결과를 확인하며 소스코드를 수정한다.

__빌드/배포 파이프라인 설계__  
빌드/배포 파이프라인은 통합 및 배포까지 이어지는 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것을 말한다.
배포 파이프라인 절차는 전형적으로 빌드, 단위 테스트, 정적 분석, 배포 과정을 거친다.
그리고 이를 구현하기 위해 어떤 도구를 활용할건지 결정하고, 도구 사이의 연계 방법을 정의해야한다.
클라우드 환경이 활성화되면 인프라 구성을 마치 프로그래밍하는 것처럼 처리할 수  있게 됐는데, 이를 Infrastructure as Code라 한다.
이를 이용하면 배포 파이프라인 절차를 완벽하게 자동화 할 수 있고 코드이기 때문에 재사용이 가능하다.

__경험으로 획득한 지혜: 마이크로서비스 관리/운영 패턴__  
OSS는 넷플릭스가  마이크로서비스를 개발하고 운영하며 생긴 노하우를 공유하는 오픈소스이다.
이는 마이크로서비스 관리와 운영을 지원하는 마이크로서비스 어플리케이션 대표 패턴이 되었다.
파보탈에서는 스프링 부트 프레임워크에서 OSS가 잘 돌아갈 수 있도록 '스프링 클라우드'를 만들었고, 이는 마이크로서비스 개발에 대표 프레임워크가 되었다.

__스프링 클라우드: 스프링부트+OSS__  
스프링 클라우드는 스프링 프레임워크 개발 회사인피보탈에서 넷플릭스가 공개한 줄, 유레카, 히스트릭스, 리본 등의
넷플릭스 오픈소스를 스프링 부트에서 쉽게 사용하도록 통합한 것이다.

__다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴__  
클라이언트가 여러 개의 마이크로 서비스를 호출하기 위해서는 최적의 경로를 찾아주는 라우팅기능과 적절한 부하 분산을 위한 로드 밸런싱 기능이 필요하다.
라우터는 최적 경로 탐색을 위해 서비스에 해당하는 IP 주소를 알아야하는데,
클라우드 환경에서는 백엔드의 IP가 유동적일 수 있기 때문에 이 정보에 대한 관리가 필요하다. 
이렇게 마이크로서비스의 서비스 명칭과 유동적 IP 정보를 매칭해서 보관하는 저장소를 두는 것을 서비스 레지스트리 패턴이라고한다.
각 서비스 인스턴스가 로딩될 때 자신의 명칭과 IP주소를 레지스트리에 등록하면,
클라이언트가 해당서비스명을 호출할 때 라우터가 레지스트리를 검색해 서비스 이름과 매핑된 IP를 확인하고 호출한다.

__서비스 단일 진입을 위한 API 게이트웨이 패턴__  
여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하게 된다면 호출 관계가 복잡해 질 수 있는데 이를 통제하기 위해서 단일 진입점을 만들어 여러 서비스 접근을 제어한다.
이 단일 진입점에서는 다양한 기능을 제공한다.

1. 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱  
2. 보안: 권한 서비스와 연계한 인증/인가  
3. 로그 집계 서비스와 연계한 로깅 (예: API 소비자 정보)  
4. 메트릭 (Metric) (예: 에러율)  
5. 트레이싱 서비스와 연계한 서비스 추적 (예: 트래킹 ID 기록)  
6. 모니터링 서비스와 연계한 장애 격리 (서킷 브레이커 패턴)  

이러한 API 게이트웨이 패턴은 스프링 클라우드의 스프링 API 게이트웨이 서비스 제품으로 구현 할 수 있다.  

__BFF 패턴__  
BFF(Backend For Frontend) 패턴은 API 게이트웨이와 같은 진입점을 하나로 두지 않고 프런트엔드 유형에 따라 각각 진입점을 두는 패턴이다.
웹, 모바일 등 프런트엔드에 따라 최적화된 처리를 수행할 수 있도록 구성하고, 공통적인 인증/인가, 로깅 처리는 통합 게이트웨이를 두어 처리하도록 구성한다.

[그림]BFF 흐름도  
![ch2_1](https://user-images.githubusercontent.com/50389148/192147543-103226f2-8406-4ed2-9cf8-306b397dfd4c.PNG)

__외부 구성 저장소 패턴__  
어플리케이션에 데이터베이스 연결 정보, 파일 스토리지 정보 등이 포함된다면 이런 정보들이 변경될 때 재배포가 필요하고 이로인해 서비스를 중단해야 한다. 
또한 여러 마이크로서비스의 동일 정보를 수정할 때도 주의가 필요하기 때문에 이런 자원의 설정 정보를 쉽고 일관되게 변경하도록 관리가 필요하다.
이를 위한 것이 외부 저장소 패턴이다. 외부 저장소는 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 저장하는 백업 저장소이다. 
Heroku에서 발표한 Twelve-Factor라는 클라우드 네이티브 어플리케이션에서는 컨피그(config)라는 원칙은
어플리케이션이 배포되는 환경(스테이징, 프로덕션, 개발, 테스트 환경)이 매번 달라지기 때문에 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 말한다.
이러한 정보는 배포 환경이 변경됐을 때 어플리케이션 또한 변경되어야 하기 때문이다.
분리해야할 환경 정보로는 데이터베이스 연결정보, 배포 시 변경해야 할 호스트명, 백엔드 서비스의 연결 리소스 정보, 개발 서버, 테스트, 운영 서버의 IP 주소등이 있다.

__인증/인가 패턴__  
1. 중앙 집중식 세션 관리  
기존 모노리스 방식에서는 사용자의 로그인 정보 및 권한 정보를 서버 세션에 저장하고 이용했다.
그러나 마이크로서비스는 로드 밸런싱 처리 등으로 세션 정보가 손실 될 수 있기 때문에 각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장한다.
세션 저장소로 보통 레디스(Redis)나 맴캐시드(Memcached)를 사용한다.    
2. 클라이언트 토큰  
세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장한다. 토큰에는 사용자의 권한 정보를 담고 있어 사용자의 요청시 서버로 전송하여 이를 검토후 인가 처리 된다.  
3. API 게이트웨이를 사용한 클라이언트 토큰  
사용자 인증 프로세스는 토큰 인증 프로세스와 유사하다. 차이점은 API 게이트웨이가 외부 요청의 입구로 추가된다는 것이다. 
또한 인증/인가 처리를 위한 별도의 전담 서비스를 만들어 다른 서비스의 인증/인가 처리를 위임할 수 있다.

__장애 및 실패 처리를 위한 서킷 브레이커 패턴__  
여러 서비스로 구성된 시스템에서는 한 서비스에 장애가 발생했을 때 다른 서비스가 영향을 받을 수 있다.
이런 장애가 발생했을 때 장애 서비스 격리를 유연하게 처리할 수 있는 방법이 서킷 브레이커 패턴이다.
서비스에 문제가 생겼을 때 자연스럽게 정상적인 서비스로 흐름을 변경시켜야 하는데 이를 위해선 실시간으로 서비스들을 모니터링해야하고
장애가 감지되면 다른 서비스에 전이되지 않도록 차단하는 것이 서킷 브레이커 패턴이다.
A서비스가 B서비스를 호출하여 자신의 서비스를 제공하는데 B서비스에 장애가 발생했을 때
B서비스 호출에 대한 연속 실패 횟수가 임계값을 초과하면 호출 회로를 차단한다.
그리고 폴백(fallback) 메서드를 지정해 자연스럽게 처리가 진행되도록한다.

__모니터링과 추적 패턴__  
마이크로서비스의 장애를 감지하려면 모니터링하고 추적하는 패턴이 필요하다.
스프링 클라우드에서는 히스트릭스라는 라이브러리를 제공하고, 히스트릭스 라이브러리가 배포된 서비스를 모니터링할 수 있는 대시보드를 제공한다.
트위터에서 공개한 집킨(Zipkin) 오픈소스는 각 서비스의 트랜잭션 호출을 추적하여 구간별 장애 포인트를 확인 할 수 있다.
 
__중앙화된 로그 집계 패턴__  
마이크로서비스가 탄련적으로 변화하는 과정에서 생성과 삭제에 따라 로컬 로그가 소멸될 수 있다.
로그는 서비스가 실행되는 동안 계속적으로 기록되어야 하기 때문에 이런 상황에 필요한 것이 중앙화된 로그 집계 패턴이다. 
대표적으로 사용되는 기술은 ELK로, 엘라스틱서치(Elasticsearch), 로그스태시(Logstash), 키바나(Kibana)라는 세가지 오픈소스 프로젝트 기반의 데이터 분석환경을 구현한 것이다.
ELK를 이용하면 각 서비스 인스턴스 로그를 집계해 중앙에서 관리할 수 있으며 손쉽게 분석 할 수 있다.  
1. Elasticsearch: 분산형검색, 분석 엔진 (정형, 비정형, 위치 정보, 메트릭 등 원하는 방법으로 검색을 수행/결합)      
2. Logstash: 로그 집합기 (데이터를 수집해 변환한 뒤 보관소로 보냄)  
3. Kibana: 시각화
   
__서비스 메시 패턴__  
MSA를 구축하기 위한 서비스 탐색, 서킷 브레이크, 로드 밸런싱 등의 기능을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 것리 서비스 메시 패턴이다.

#### 애플리케이션 패턴 ####

__UI컴포지트 패턴 또는 마이크로 프런트엔드__  
프런트엔드도 마이크로서비스처럼 기능별로 분리하고 이를 조합해 동작하는 통합 프레임 화면을 만들어 구현한다.
이렇게해야 각 서비스를 독립적으로 빌드 하고 배포 할 수 있다. 

__마이크로서비스 통신 패턴__  
1. 동기 통신 방식  
동기 통신 방식은 클라이언트에서 서버 측에 존재하는 마이크로서비스 REST API를 호출할 때 사용되는 기본 통신 방법이다.
 
[그림] 프런트엔드에서 백엔드 호출  
![ch2_2](https://user-images.githubusercontent.com/50389148/192147968-eb2d739f-08ce-4502-add9-a2306d36d4b9.PNG)

2. 비동기통신  
마이크로서비스 사이에도 동기 통신을 많이 쓰고 구현하기 쉽지만 장애가 발생했을 때의 문제를 해결하기 위해서 비동기 통신이 필요하다. 
메시지 기반의 비동기(asynchronous) 호출은 응답을 기다리지 않고 다음 일을 처리한다.
동기식처럼 완결성을 보장할 수 없기 때문에 이를 보장하기 위한 메커니즘이 필요하다.
이를 위한 메커니즘은 아파치 카프카(Apach Kafka), 레빗엠큐(RabbitMQ), 액티브엠큐(ActiveMQ) 같은 메시지 브로커를 활용하여 구현한다.
메시지를 보내는 생산자와 메시지를 처리하는 소비자는 서로 직접 연결되지 않으며 메시지 브로커에 의해 연결된다. 
메시지 브로커에 메시지를 전달하고 다른일을 처리하는 동안 메시지 브로커가 결과 전송을 보장한다. 
탄력적 환경이라면 메시지 브로커는 서비스 요구의 증가에 따라 효율적으로 확장 될 수 있다.  

__저장소 분리 패턴__  
통합 저장소의 경우 마이크로서비스로 기능을 분리하더라도 요청이 증가할 경우 스케일 아웃이 무용지물이 될 수 있다.
이를 보완하는 것이 저장소 분리 패턴이다. 저장소 분리 패턴은 각 마이크로서비스의 비즈니스를 처리하기 위한 데이터를 직접 소유하는 것이다.
때문에 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 공개된 API를 통해서만 접근할 수 있다.
또한 이렇게 저장소가 분리되어 있기 때문에 자유롭게 저장소의 종류를 선택할 수 있다.

__분산 트랜잭션 패턴__  
저장소를 분리할 때, 여러 서비스에 걸처 처리되는 기능의 경우 데이터의 일관성에 문제가 발생할 수 있다.
분산 트랜잭션 처리의 전통적 방법은 2단계 커밋 방법이다. 2단계 커밋은 분산 데이터베이스 환경에서 원자성(atomicity)을 보장하기 위해 
트랜젝션에 포함된 모든 노드가 커밋되거나 롤백되는 매커니즘이다.
그러나 이 방법은 효율적이지 못하다. 이른 보완한 마이크로서비스의 독립적인 분산 트랜잭션 처리를 지원하는 패턴은 사가(Saga)패턴이다.
사가 패턴은 여러개의 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용하여 데이터의 정합성을 맞춘다.
로컬 트랜잭션은 자신의 데이터베이스를 업데이트한 다음, 사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 이벤트를 게시해 데이터의 일관성을 맞춘다.

[그림] 분산 트랜잭션과 사가 패턴  
![ch2_3](https://user-images.githubusercontent.com/50389148/192147970-0d83ee8a-f9ac-46a0-bdcc-cdec14b78667.PNG)

만약 트랜잭션 결과에 따라 롤백이 필요하다면 보상 트랜잭션을 사용한다. 보상 트랜잭션은 처리 실패시 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리는 트랜잭션이다. 

__읽기와 쓰기 분리: CQRS 패턴__  
서비스 성능 향상을 위해 인스턴스를 스케일 아웃했을 경우 데이터 읽기/수정 작업으로 인한 리소스의 교착상태가 발생할 수 있다.
이문제의 해법이 CQRS 패턴인데, CQRS(Command Query Responsibility Segregation)는 명령 조회 책임 분리를 의미한다.
하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 구성해 쓰기 서비스와 조회 서비스를 분리 할 수도 있고,
물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 만들수도 있다.

__CQRS의 기능 연계__  
마이크로서비스가 독자적인 저장소를 갖도록한 아래 그림을 보면, 각각의 마이크로서비스는 원천 정보를 보유한 저장소를 가지고 있고
자신의 서비스가 변경되면 변경 이벤트를 발행해 이를 사용하는 다른 마이크로서비스에 적용되도록 한다. 

[그림] CQRS 패턴을 이용한 기능 연계  
![ch2_4](https://user-images.githubusercontent.com/50389148/192147974-0a727dd5-0572-45be-bd92-5502e49d7e65.PNG)

__쓰기 최적화: 이벤트 소싱 패턴__  
저장소에 저장하는 일과 메시지를 보내는 작업은 언제나 완전하게 진행되어야 한다.
비즈니스를 처리할 때 데이터 처리 상태의 결과값을 계산하고 데이터의 최종 상태를 확정해서 저장하는 방식의 경우
객체의 상태변경이 누적될 때마다 과정이 복잡해지고 처리속도가 느려진다.
이를 보완하기 위해서 이벤트 소싱(event sourcing) 기법을 사용하여 상태 변경 이벤트를 계산해
데이터 모델로 변경하지 않고 바로 이벤트 저장소에 저장하는 방법을 사용한다.
처음부터 모든 트랜잭션을 처리하지 않고 매일 자정에 상태를 계산헤 스냅숏으로 저장한 후 현재 상태가 필요해질 때 스냅숏 이후의 트랜잭션만 처리한다.
다시 말해, 이벤트 소싱은 모든 트랜잭션의 상태를 바로 계산하지 않고 별도의 이벤트 저장소에 저장하는 방식이다.
이벤트 저장소는 데이터베이스 역할뿐 아니라 메시지 브로커처럼 동작해 쓰기 성능을 최적화 시킨다.

[그림] 이벤트 스트림 저장  
![ch2_5](https://user-images.githubusercontent.com/50389148/192148392-d2b48ffe-3c29-46d8-9cd3-69c024e30097.PNG)
